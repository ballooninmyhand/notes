### RDB 持久化

RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为 dump.rdb。可以通过配置设置自动做快照持久化的方式。

**RDB 文件保存过程**

- redis 调用 fork，现在有了子进程和父进程
- 父进程继续处理客户端请求，子进程负责将内存内容写入临时文件。子进程地址空间内的数据是 fork 时刻整个数据库的快照
- 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后退出
- 客户端也可以使用 save 或 bgsave 命令通知 redis 做一次快照持久化。save 是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有客户端请求，这种方式会阻塞所有客户端请求，所以不推荐使用
- 另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量同步数据。如果数据量大，并且写操作较多时，必然引起大量的磁盘 IO 操作，可能会严重影响性能

**优势**

- 采用该方式，整个 redis 数据库将只包含一个文件，这样非常方便进行备份
- 可以很容易的将 RDB 文件移动到其他的存储介质
- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
- RDB 可以最大化 redis 的性能：父进程在保存 RDB 文件时唯一要做的是 fork 一个子进程，然后这个子进程会处理所有保存工作，父进程无须执行任何磁盘 IO 操作

**劣势**

- RDB 文件保存的是整个数据集的状态，所以可能每隔几分钟才保存一次 RDB 文件。这种情况下，一旦发生故障停机，就可能丢失几分钟的数据
- 每次保存 RDB 的时候，redis 都要 fork 出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，fork 可能会非常耗时，造成服务器停止处理客户端



### AOF 持久化

redis 会将每一个收到的写命令都通过 write 函数追加到文件中（默认是 appendonly.aof）。

**AOF 文件保存过程**

- redis 调用 fork ，现在有父子两个进程
- 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
- 父进程继续处理 client 请求，除了把写命令写入到原来的 aof 文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
- 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
- 现在父进程可以使用临时文件替换老的 aof 文件，并重命名，后面收到的写命令也开始往新的 aof 文件中追加。

**优势**

- 使用 AOF 持久化会让 redis 变得非常耐久：可以设置不用的 fsync 策略，比如每秒钟一次 fsync。在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据
- AOF 文件是一个只进行追加操作的日志文件（append only log），即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等），redis-check-aof 工具也可以轻易修复这种问题
- Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合
- AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单

**劣势**

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积
- 根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效





